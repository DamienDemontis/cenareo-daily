-- March Snippets: Object-Oriented & Design Patterns
INSERT INTO snippets (month, day, title, code, explanation, language_id, category_id) VALUES
(3, 1, 'Singleton Pattern', 'class Singleton {
private:\n    static Singleton* instance;
    Singleton() {}
public:\n    static Singleton* getInstance() {
        if (!instance) instance = new Singleton();
        return instance;
    }
    Singleton(const Singleton&) = delete;
    void operator=(const Singleton&) = delete;
};
Singleton* Singleton::instance = nullptr;', 'Singleton ensures single instance. Private constructor prevents direct creation. Static method controls access. Used for configs, loggers.', 3, 9),
(3, 2, 'Factory Pattern', 'class ShapeFactory {
public:\n    enum ShapeType { CIRCLE, SQUARE, TRIANGLE };
    static unique_ptr<Shape> createShape(ShapeType type) {
        switch(type) {
            case CIRCLE: return make_unique<Circle>();
            case SQUARE: return make_unique<Square>();
            case TRIANGLE: return make_unique<Triangle>();
        }
        return nullptr;
    }
};', 'Factory pattern creates objects without specifying exact class. Encapsulates object creation logic. Enables loose coupling and flexibility.', 3, 9),
(3, 3, 'Observer Pattern', 'class Subject {
    vector<Observer*> observers;
public:\n    void attach(Observer* obs) { observers.push_back(obs); }
    void detach(Observer* obs) {
        observers.erase(remove(observers.begin(), observers.end(), obs));
    }
    void notify() {
        for (auto obs : observers) obs->update(this);
    }
};', 'Observer defines one-to-many dependency. Subjects notify observers of changes. Used in MVC, event systems, reactive programming.', 3, 9),
(3, 4, 'Python Class Inheritance', 'class Animal:\n    def __init__(self, name):\n        self.name = name\n    def speak(self):\n        raise NotImplementedError\n\nclass Dog(Animal):\n    def speak(self):\n        return f"{self.name} says Woof!"\n\nclass Cat(Animal):\n    def speak(self):\n        return f"{self.name} says Meow!"\n\nanimals = [Dog("Rex"), Cat("Whiskers")]\nfor animal in animals:\n    print(animal.speak())', 'Inheritance creates is-a relationships. Child classes extend parent. Polymorphism allows uniform interface. Override methods for specialization.', 1, 9),
(3, 5, 'Virtual Functions C++', 'class Base {
public:\n    virtual void print() { cout << "Base\\n"; }\n    virtual ~Base() = default;\n};\nclass Derived : public Base {\npublic:\n    void print() override { cout << "Derived\\n"; }\n};\nvoid process(Base* obj) {\n    obj->print();  // Runtime polymorphism\n}', 'Virtual functions enable runtime polymorphism. Override in derived classes. Virtual destructor prevents memory leaks. vtable manages dispatch.', 3, 9),
(3, 6, 'Decorator Pattern', 'class Coffee {
public:\n    virtual double cost() = 0;
    virtual string description() = 0;
};
class CoffeeDecorator : public Coffee {
protected:\n    Coffee* coffee;
public:\n    CoffeeDecorator(Coffee* c) : coffee(c) {}
};
class Milk : public CoffeeDecorator {
public:\n    double cost() override { return coffee->cost() + 0.5; }
    string description() override { return coffee->description() + ", milk"; }
};', 'Decorator adds functionality without altering structure. Wraps objects recursively. Alternative to subclassing. Used in I/O streams.', 3, 9),
(3, 7, 'Thread Pool Implementation', '#include <thread>\n#include <queue>\n#include <condition_variable>\nclass ThreadPool {
    vector<thread> workers;
    queue<function<void()>> tasks;
    mutex queue_mutex;
    condition_variable cv;
    bool stop = false;
public:\n    ThreadPool(size_t threads) {
        for(size_t i = 0; i < threads; ++i)\n            workers.emplace_back([this] { work(); });
    }
    void enqueue(function<void()> task) {
        unique_lock<mutex> lock(queue_mutex);
        tasks.push(task);
        cv.notify_one();
    }
};', 'Thread pools reuse threads for tasks. Avoids creation overhead. Queue manages work distribution. Essential for scalable concurrent systems.', 3, 6),
(3, 8, 'SQL Transaction ACID', 'BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
IF @@ERROR != 0\n    ROLLBACK TRANSACTION;
ELSE\n    COMMIT TRANSACTION;
\n-- Isolation levels\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ', 'ACID ensures database reliability. Atomicity: all or nothing. Consistency: valid states. Isolation: concurrent safety. Durability: permanent changes.', 10, 3),
(3, 9, 'Strategy Pattern', 'class SortStrategy {
public:\n    virtual void sort(vector<int>& data) = 0;
};
class QuickSort : public SortStrategy {
    void sort(vector<int>& data) override { /* quicksort */ }
};
class MergeSort : public SortStrategy {
    void sort(vector<int>& data) override { /* mergesort */ }
};
class Sorter {
    SortStrategy* strategy;
public:\n    void setStrategy(SortStrategy* s) { strategy = s; }
    void sort(vector<int>& data) { strategy->sort(data); }
};', 'Strategy encapsulates algorithms. Switch algorithms at runtime. Eliminates conditional logic. Open/closed principle compliance.', 3, 9),
(3, 10, 'JavaScript Prototypes', 'function Person(name) {
    this.name = name;
}
Person.prototype.greet = function() {
    return `Hello, I''m ${this.name}`;
};
\nfunction Employee(name, role) {
    Person.call(this, name);
    this.role = role;
}
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;
Employee.prototype.work = function() {
    return `${this.name} works as ${this.role}`;
};', 'Prototypes enable inheritance in JavaScript. Objects inherit from prototype chain. Methods shared across instances. Memory efficient.', 5, 9),
(3, 11, 'Memento Pattern', 'class Memento {
    string state;
public:\n    Memento(const string& s) : state(s) {}
    string getState() const { return state; }
};
class Originator {
    string state;
public:\n    void setState(const string& s) { state = s; }
    Memento saveToMemento() { return Memento(state); }
    void restoreFromMemento(const Memento& m) { state = m.getState(); }
};', 'Memento captures object state for restoration. Implements undo/redo. Preserves encapsulation. Used in text editors, games.', 3, 9),
(3, 12, 'Python Metaclasses', 'class SingletonMeta(type):\n    _instances = {}
    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=SingletonMeta):\n    def __init__(self):\n        self.connection = "Connected"\n\ndb1 = Database()\ndb2 = Database()\nprint(db1 is db2)  # True', 'Metaclasses control class creation. type is default metaclass. Customize class behavior, attributes. Advanced Python magic.', 1, 9),
(3, 13, 'Command Pattern', 'class Command {
public:\n    virtual void execute() = 0;
    virtual void undo() = 0;
};
class LightOnCommand : public Command {
    Light* light;
public:\n    LightOnCommand(Light* l) : light(l) {}
    void execute() override { light->on(); }
    void undo() override { light->off(); }
};
class RemoteControl {
    vector<Command*> commands;
public:\n    void setCommand(int slot, Command* cmd) { commands[slot] = cmd; }
    void pressButton(int slot) { commands[slot]->execute(); }
};', 'Command encapsulates requests as objects. Enables undo, queuing, logging. Decouples sender from receiver. Used in GUI buttons, macros.', 3, 9),
(3, 14, 'Proxy Pattern', 'class ImageProxy : public Image {
    RealImage* realImage;
    string filename;
public:\n    ImageProxy(const string& file) : filename(file), realImage(nullptr) {}
    void display() override {
        if (!realImage) {
            realImage = new RealImage(filename);  // Lazy loading\n        }
        realImage->display();
    }
    ~ImageProxy() { delete realImage; }
};', 'Proxy provides placeholder for object. Controls access, lazy loading, caching. Virtual proxy delays expensive operations. Security proxy adds access control.', 3, 9),
(3, 15, 'Template Method Pattern', 'class DataProcessor {
public:\n    void process() {
        readData();
        processData();
        writeData();
    }
protected:\n    virtual void readData() = 0;
    virtual void processData() = 0;
    virtual void writeData() = 0;
};
class CSVProcessor : public DataProcessor {
protected:\n    void readData() override { /* Read CSV */ }
    void processData() override { /* Process */ }
    void writeData() override { /* Write CSV */ }
};', 'Template method defines algorithm skeleton. Subclasses override specific steps. Enforces algorithm structure. Hollywood principle: dont call us.', 3, 9),
(3, 16, 'Rust Traits', 'trait Drawable {
    fn draw(&self);
}
struct Circle { radius: f64 }
struct Square { side: f64 }
impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle with radius {}", self.radius);
    }
}
impl Drawable for Square {
    fn draw(&self) {
        println!("Drawing square with side {}", self.side);
    }
}
fn render(shape: &dyn Drawable) {
    shape.draw();
}', 'Traits define shared behavior. Similar to interfaces. Static or dynamic dispatch. Zero-cost abstractions. Rust polymorphism foundation.', 7, 9),
(3, 17, 'Builder Pattern', 'class CarBuilder {
    Car car;
public:\n    CarBuilder& setEngine(const string& engine) {
        car.engine = engine; return *this;
    }
    CarBuilder& setWheels(int wheels) {
        car.wheels = wheels; return *this;
    }
    CarBuilder& setColor(const string& color) {
        car.color = color; return *this;
    }
    Car build() { return car; }
};
// Usage: Car car = CarBuilder().setEngine("V8").setWheels(4).build();', 'Builder constructs complex objects step-by-step. Fluent interface for readability. Separates construction from representation. Immutable objects.', 3, 9),
(3, 18, 'Adapter Pattern', 'class LegacyPrinter {
public:\n    void printOldFormat(const string& text) { /* ... */ }
};
class ModernPrinter {
public:\n    virtual void print(const string& text) = 0;
};
class PrinterAdapter : public ModernPrinter {
    LegacyPrinter* legacy;
public:\n    PrinterAdapter(LegacyPrinter* l) : legacy(l) {}
    void print(const string& text) override {
        legacy->printOldFormat(text);
    }
};', 'Adapter makes incompatible interfaces work together. Wraps existing class with new interface. Enables legacy code integration.', 3, 9),
(3, 19, 'Python Abstract Base Classes', 'from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self): pass\n    \n    @abstractmethod\n    def perimeter(self): pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)', 'ABC enforces interface contracts. @abstractmethod must be implemented. Cannot instantiate abstract classes. Ensures consistent APIs.', 1, 9),
(3, 20, 'Composite Pattern', 'class Component {
public:\n    virtual void operation() = 0;
    virtual void add(Component*) {}
    virtual void remove(Component*) {}
};
class Leaf : public Component {
    void operation() override { /* leaf operation */ }
};
class Composite : public Component {
    vector<Component*> children;
public:\n    void add(Component* c) override { children.push_back(c); }
    void operation() override {
        for (auto child : children) child->operation();
    }
};', 'Composite treats objects uniformly. Tree structures with leaf and composite nodes. Part-whole hierarchies. Used in GUI, file systems.', 3, 9),
(3, 21, 'Chain of Responsibility', 'class Handler {
    Handler* next;
public:\n    void setNext(Handler* h) { next = h; }
    virtual void handle(Request& req) {
        if (canHandle(req)) process(req);
        else if (next) next->handle(req);
    }
    virtual bool canHandle(Request&) = 0;
    virtual void process(Request&) = 0;
};', 'Chain passes requests along handlers. Each decides to process or forward. Decouples sender from receivers. Used in event handling, logging.', 3, 9),
(3, 22, 'Go Interfaces', 'type Writer interface {
    Write([]byte) (int, error)\n}
type ConsoleWriter struct{}
func (cw ConsoleWriter) Write(data []byte) (int, error) {
    n, err := fmt.Println(string(data))\n    return n, err\n}
type FileWriter struct { file *os.File }
func (fw FileWriter) Write(data []byte) (int, error) {
    return fw.file.Write(data)\n}
func save(w Writer, data []byte) {
    w.Write(data)\n}', 'Go interfaces are implicit. Types satisfy interface by implementing methods. Duck typing with compile-time safety. Composition over inheritance.', 6, 9),
(3, 23, 'Flyweight Pattern', 'class Character {
    char symbol;
    Font* font;  // Shared\npublic:\n    Character(char s, Font* f) : symbol(s), font(f) {}
    void display(int x, int y) {
        font->render(symbol, x, y);
    }
};
class FontFactory {
    unordered_map<string, Font*> fonts;
public:\n    Font* getFont(const string& name) {
        if (!fonts[name]) fonts[name] = new Font(name);
        return fonts[name];
    }
};', 'Flyweight shares common data between objects. Intrinsic vs extrinsic state. Reduces memory usage. Used in text editors, games.', 3, 9),
(3, 24, 'Bridge Pattern', 'class Renderer {
public:\n    virtual void renderCircle(float x, float y, float r) = 0;
};
class VectorRenderer : public Renderer { /* ... */ };
class RasterRenderer : public Renderer { /* ... */ };
\nclass Shape {
protected:\n    Renderer* renderer;
public:\n    Shape(Renderer* r) : renderer(r) {}
    virtual void draw() = 0;
};
class Circle : public Shape {
    float x, y, radius;
public:\n    void draw() override { renderer->renderCircle(x, y, radius); }
};', 'Bridge separates abstraction from implementation. Both can vary independently. Avoids class explosion. Prefer composition over inheritance.', 3, 9),
(3, 25, 'Visitor Pattern', 'class Visitor {
public:\n    virtual void visit(Circle*) = 0;
    virtual void visit(Square*) = 0;
};
class Shape {
public:\n    virtual void accept(Visitor*) = 0;
};
class Circle : public Shape {
    void accept(Visitor* v) override { v->visit(this); }
};
class AreaCalculator : public Visitor {
    void visit(Circle* c) override { /* calc circle area */ }
    void visit(Square* s) override { /* calc square area */ }
};', 'Visitor adds operations without modifying classes. Double dispatch for type resolution. Open/closed principle. Used in compilers, AST processing.', 3, 9),
(3, 26, 'TypeScript Mixins', 'type Constructor<T = {}> = new (...args: any[]) => T;
function Timestamped<T extends Constructor>(Base: T) {
    return class extends Base {
        timestamp = Date.now();
    };
}
function Activatable<T extends Constructor>(Base: T) {
    return class extends Base {
        isActive = false;
        activate() { this.isActive = true; }
        deactivate() { this.isActive = false; }
    };
}
class User { name = "user"; }
const TimestampedUser = Timestamped(Activatable(User));', 'Mixins add functionality to classes. Composition of behaviors. Alternative to multiple inheritance. Flexible code reuse pattern.', 12, 9),
(3, 27, 'State Pattern', 'class State {
public:\n    virtual void handle(Context*) = 0;
};
class ConcreteStateA : public State {
    void handle(Context* ctx) override {
        // Do work, then transition\n        ctx->setState(new ConcreteStateB());
    }
};
class Context {
    State* state;
public:\n    void setState(State* s) { delete state; state = s; }
    void request() { state->handle(this); }
};', 'State pattern changes object behavior based on state. Eliminates conditionals. State machines. Used in TCP connections, UI workflows.', 3, 9),
(3, 28, 'Interpreter Pattern', 'class Expression {
public:\n    virtual int interpret(Context&) = 0;
};
class Number : public Expression {
    int value;
public:\n    Number(int v) : value(v) {}
    int interpret(Context&) override { return value; }
};
class Plus : public Expression {
    Expression *left, *right;
public:\n    Plus(Expression* l, Expression* r) : left(l), right(r) {}
    int interpret(Context& ctx) override {
        return left->interpret(ctx) + right->interpret(ctx);
    }
};', 'Interpreter evaluates language grammar. Abstract syntax tree. Each rule is a class. Used in SQL parsing, regex, calculators.', 3, 9),
(3, 29, 'Null Object Pattern', 'class Logger {
public:\n    virtual void log(const string&) = 0;
};
class ConsoleLogger : public Logger {
    void log(const string& msg) override { cout << msg << endl; }
};
class NullLogger : public Logger {
    void log(const string&) override { /* Do nothing */ }
};
class App {
    Logger* logger;
public:\n    App(Logger* l = new NullLogger()) : logger(l) {}
    void doWork() { logger->log("Working..."); }
};', 'Null object provides default do-nothing behavior. Eliminates null checks. Polymorphic approach to optional behavior. Cleaner code flow.', 3, 9),
(3, 30, 'Python Multiple Inheritance', 'class Flyable:\n    def fly(self):\n        return "Flying"\n\nclass Swimmable:\n    def swim(self):\n        return "Swimming"\n\nclass Duck(Flyable, Swimmable):\n    def quack(self):\n        return "Quack!"\n\n# Method Resolution Order (MRO)\nprint(Duck.__mro__)\n# Diamond problem solution\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B, C): pass  # Python C3 linearization', 'Multiple inheritance allows multiple parent classes. MRO determines method lookup order. C3 linearization resolves diamonds. Use carefully.', 1, 9),
(3, 31, 'SOLID Principles Summary', '// Single Responsibility\nclass User { /* user data */ };
class UserDB { /* database ops */ };
\n// Open/Closed\nclass Shape { virtual double area() = 0; };
\n// Liskov Substitution\n// Derived classes must be substitutable\n\n// Interface Segregation\nclass Printer { virtual void print() = 0; };
class Scanner { virtual void scan() = 0; };
\n// Dependency Inversion\nclass App {
    IDatabase* db;  // Depend on abstraction\npublic:\n    App(IDatabase* database) : db(database) {}
};', 'SOLID guides OOP design. SRP: one reason to change. OCP: extend, dont modify. LSP: behavioral subtyping. ISP: specific interfaces. DIP: abstractions.', 3, 9);
-- February Snippets: Advanced Algorithms & System Programming
INSERT INTO snippets (month, day, title, code, explanation, language_id, category_id) VALUES
(2, 1, 'Binary Search Implementation', '#include <stdio.h>\nint binary_search(int arr[], int size, int target) {
    int left = 0, right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}', 'Binary search divides search space in half each iteration. O(log n) complexity requires sorted array. Returns index or -1 if not found.', 2, 4),
(2, 2, 'Quick Sort Algorithm', '#include <stdio.h>\nvoid quicksort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quicksort(arr, low, pi - 1);
        quicksort(arr, pi + 1, high);
    }
}
int partition(int arr[], int low, int high) {
    int pivot = arr[high], i = low - 1;
    for (int j = low; j < high; j++)\n        if (arr[j] < pivot) swap(&arr[++i], &arr[j]);
    swap(&arr[i + 1], &arr[high]);
    return i + 1;
}', 'Quick sort uses divide-and-conquer with pivot partitioning. Average O(n log n), worst O(nÂ²). In-place sorting with recursive calls.', 2, 4),
(2, 3, 'Python Decorator Pattern', '@timer_decorator\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nimport time\ndef timer_decorator(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        print(f"{func.__name__} took {time.time()-start:.4f}s")\n        return result\n    return wrapper', 'Decorators wrap functions to add behavior. @syntax is syntactic sugar. Useful for logging, timing, caching, authentication.', 1, 9),
(2, 4, 'Heap Data Structure', '#include <stdio.h>\nvoid heapify(int arr[], int n, int i) {
    int largest = i, left = 2*i + 1, right = 2*i + 2;
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        heapify(arr, n, largest);
    }
}', 'Max heap maintains parent >= children property. Heapify restores heap property. Used in heap sort and priority queues. O(log n) operations.', 2, 3),
(2, 5, 'C++ Lambda Expressions', '#include <iostream>\n#include <vector>\n#include <algorithm>\nint main() {
    std::vector<int> nums = {1, 2, 3, 4, 5};
    auto sum = 0;
    std::for_each(nums.begin(), nums.end(), [&sum](int n) {
        sum += n * n;
    });
    auto evens = std::count_if(nums.begin(), nums.end(),\n        [](int n) { return n % 2 == 0; });
    std::cout << "Sum of squares: " << sum << ", Evens: " << evens;\n}', 'Lambdas are inline anonymous functions. [&] captures by reference, [=] by value. Perfect for STL algorithms and callbacks.', 3, 9),
(2, 6, 'Fork System Call', '#include <unistd.h>\n#include <stdio.h>\nint main() {
    pid_t pid = fork();
    if (pid < 0) {
        perror("Fork failed");
    } else if (pid == 0) {
        printf("Child process: PID=%d, Parent=%d\\n", getpid(), getppid());\n    } else {\n        printf("Parent process: PID=%d, Child=%d\\n", getpid(), pid);\n        wait(NULL);\n    }\n    return 0;\n}', 'fork() creates child process. Returns 0 in child, child PID in parent, -1 on error. Essential for process creation in Unix systems.', 2, 6),
(2, 7, 'JavaScript Async/Await', 'async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const user = await response.json();
        const posts = await fetch(`/api/posts?user=${userId}`);
        return { user, posts: await posts.json() };
    } catch (error) {
        console.error("Fetch failed:", error);\n        return null;\n    }
}', 'Async/await simplifies promise chains. async functions return promises. await pauses execution until promise resolves. Error handling with try/catch.', 5, 11),
(2, 8, 'Graph BFS Algorithm', '#include <queue>\n#include <vector>\nvoid BFS(std::vector<std::vector<int>>& graph, int start) {
    std::vector<bool> visited(graph.size(), false);
    std::queue<int> q;
    visited[start] = true;
    q.push(start);
    while (!q.empty()) {
        int node = q.front(); q.pop();
        for (int neighbor : graph[node])\n            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
    }
}', 'BFS explores level by level using queue. Finds shortest path in unweighted graphs. O(V+E) complexity. Used in networking, AI pathfinding.', 3, 4),
(2, 9, 'SQL Join Types', 'SELECT c.name, o.total, p.title\nFROM customers c\nLEFT JOIN orders o ON c.id = o.customer_id\nINNER JOIN products p ON o.product_id = p.id\nWHERE o.date >= ''2024-01-01''\n  AND c.country = ''France''\nGROUP BY c.id, p.id\nHAVING SUM(o.total) > 1000\nORDER BY o.total DESC;', 'LEFT JOIN keeps all left records. INNER JOIN only matching. RIGHT JOIN keeps right. FULL OUTER keeps all. Essential for relational data queries.', 10, 3),
(2, 10, 'Mutex Thread Synchronization', '#include <pthread.h>\n#include <stdio.h>\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int counter = 0;
void* increment(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        pthread_mutex_lock(&mutex);
        counter++;
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}', 'Mutex prevents race conditions in multithreading. Lock before critical section, unlock after. Essential for thread-safe shared resource access.', 2, 6),
(2, 11, 'React Hooks useState', 'import React, { useState, useEffect } from ''react'';
function Counter() {
    const [count, setCount] = useState(0);
    const [double, setDouble] = useState(0);
    \n    useEffect(() => {
        setDouble(count * 2);
    }, [count]);
    \n    return (\n        <div>\n            <p>Count: {count}, Double: {double}</p>\n            <button onClick={() => setCount(count + 1)}>+</button>\n        </div>\n    );
}', 'useState manages component state. useEffect handles side effects. Dependencies array controls when effect runs. Replaces class components.', 5, 11),
(2, 12, 'Dynamic Programming - Coins', 'int coinChange(int coins[], int n, int amount) {
    int dp[amount + 1];
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
        dp[i] = INT_MAX;
        for (int j = 0; j < n; j++)\n            if (coins[j] <= i && dp[i - coins[j]] != INT_MAX)\n                dp[i] = min(dp[i], dp[i - coins[j]] + 1);
    }
    return dp[amount] == INT_MAX ? -1 : dp[amount];
}', 'DP solution for minimum coins problem. Builds solutions from smaller subproblems. O(amount * n) time, O(amount) space. Classic optimization.', 2, 4),
(2, 13, 'Python Context Manager', 'class DatabaseConnection:\n    def __enter__(self):\n        self.conn = sqlite3.connect(''db.sqlite'')\n        return self.conn\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            self.conn.rollback()\n        else:\n            self.conn.commit()\n        self.conn.close()\n\nwith DatabaseConnection() as db:\n    db.execute("INSERT INTO users VALUES (?, ?)", (name, email))', 'Context managers ensure cleanup with __enter__ and __exit__. with statement handles exceptions. Perfect for resources like files, connections.', 1, 9),
(2, 14, 'AVL Tree Rotation', 'struct Node* rotateRight(struct Node* y) {
    struct Node* x = y->left;
    struct Node* T2 = x->right;
    x->right = y;
    y->left = T2;
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
    return x;
}', 'AVL trees self-balance using rotations. Right rotation fixes left-heavy imbalance. Maintains O(log n) operations. Height difference max 1.', 2, 3),
(2, 15, 'Shell Pipe Implementation', '#include <unistd.h>\nint main() {
    int pipefd[2];
    pipe(pipefd);
    if (fork() == 0) {
        close(pipefd[0]);
        dup2(pipefd[1], STDOUT_FILENO);
        execlp("ls", "ls", "-l", NULL);
    } else {
        close(pipefd[1]);
        dup2(pipefd[0], STDIN_FILENO);
        execlp("grep", "grep", ".c", NULL);
    }
}', 'Pipes connect process stdout to stdin. pipe() creates fd pair. dup2 redirects. Implements shell | operator. Foundation of Unix philosophy.', 2, 6),
(2, 16, 'Go Goroutines', 'package main\nimport "fmt"\nfunc worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("Worker %d processing job %d\\n", id, j)\n        results <- j * 2\n    }
}
func main() {
    jobs := make(chan int, 100)\n    results := make(chan int, 100)\n    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)\n    }
}', 'Goroutines are lightweight threads. Channels enable communication. <- sends/receives. Perfect for concurrent processing. Core Go concurrency.', 6, 6),
(2, 17, 'C++ Move Semantics', '#include <vector>\nclass Buffer {
    int* data;
    size_t size;
public:\n    Buffer(Buffer&& other) noexcept\n        : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }
    Buffer& operator=(Buffer&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
        }
        return *this;
    }
};', 'Move semantics avoid expensive copies. && indicates rvalue reference. noexcept enables optimizations. Transfers ownership efficiently.', 3, 9),
(2, 18, 'Dijkstra Shortest Path', '#include <queue>\n#include <vector>\nvoid dijkstra(vector<vector<pair<int,int>>>& graph, int src) {
    vector<int> dist(graph.size(), INT_MAX);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    dist[src] = 0;
    pq.push({0, src});
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d > dist[u]) continue;
        for (auto [v, w] : graph[u])\n            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
    }
}', 'Dijkstra finds shortest paths from source. Uses priority queue for efficiency. O((V+E)log V) with heap. Works for non-negative weights.', 3, 4),
(2, 19, 'Python Generators', 'def fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nfib = fibonacci()\nfor _ in range(10):\n    print(next(fib), end=" ")\n\ndef read_large_file(file):\n    with open(file) as f:\n        for line in f:\n            yield line.strip()', 'Generators produce values lazily with yield. Memory efficient for large sequences. State preserved between calls. Perfect for streaming data.', 1, 9),
(2, 20, 'Memory Pool Allocator', 'typedef struct MemPool {
    char* memory;
    size_t size;
    size_t used;
} MemPool;
\nvoid* pool_alloc(MemPool* pool, size_t bytes) {
    if (pool->used + bytes > pool->size) return NULL;
    void* ptr = pool->memory + pool->used;
    pool->used += bytes;
    return ptr;
}
void pool_reset(MemPool* pool) {
    pool->used = 0;
}', 'Memory pools reduce allocation overhead. Pre-allocate large block, distribute chunks. Fast allocation, bulk deallocation. Great for games/embedded.', 2, 5),
(2, 21, 'TypeScript Generics', 'interface Stack<T> {
    push(item: T): void;
    pop(): T | undefined;
}
class ArrayStack<T> implements Stack<T> {
    private items: T[] = [];
    push(item: T): void { this.items.push(item); }
    pop(): T | undefined { return this.items.pop(); }
}
function identity<T>(arg: T): T { return arg; }
const numberStack = new ArrayStack<number>();', 'Generics enable type-safe reusable code. <T> is type parameter. Constraints with extends. Better than any, maintains type information.', 12, 9),
(2, 22, 'Red-Black Tree Properties', 'enum Color { RED, BLACK };
struct RBNode {
    int data;
    Color color;
    RBNode *left, *right, *parent;
};
bool isValidRB(RBNode* root, int& blackHeight) {
    if (!root) { blackHeight = 1; return true; }
    if (root->color == RED &&\n        ((root->left && root->left->color == RED) ||\n         (root->right && root->right->color == RED)))\n        return false;
    int lh, rh;
    if (!isValidRB(root->left, lh) || !isValidRB(root->right, rh))\n        return false;
    if (lh != rh) return false;
    blackHeight = lh + (root->color == BLACK ? 1 : 0);
    return true;
}', 'RB trees maintain balance via coloring rules. No red-red parent-child. Equal black heights. O(log n) guaranteed. Used in STL map.', 3, 3),
(2, 23, 'Unix Signals', '#include <signal.h>\n#include <stdio.h>\nvolatile sig_atomic_t stop = 0;
void handle_sigint(int sig) {
    printf("\\nReceived SIGINT (%d), stopping...\\n", sig);
    stop = 1;
}
int main() {
    signal(SIGINT, handle_sigint);
    printf("Press Ctrl+C to stop\\n");\n    while (!stop) {\n        // Work\n    }\n    printf("Cleanup and exit\\n");\n}', 'Signals are async notifications. SIGINT from Ctrl+C. Handler must be async-safe. volatile sig_atomic_t for flag. Essential for robust programs.', 2, 6),
(2, 24, 'WebSocket Implementation', 'const WebSocket = require(''ws'');
const wss = new WebSocket.Server({ port: 8080 });
\nwss.on(''connection'', (ws) => {
    console.log(''Client connected'');\n    \n    ws.on(''message'', (message) => {
        // Broadcast to all clients\n        wss.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) {
                client.send(`Echo: ${message}`);
            }
        });
    });
    \n    ws.send(''Welcome to WebSocket server!'');
});', 'WebSockets enable real-time bidirectional communication. Persistent connection, low latency. Perfect for chat, games, live updates.', 5, 11),
(2, 25, 'Rust Ownership', 'fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 moved to s2\n    // println!("{}", s1);  // Error: s1 no longer valid\n    \n    let s3 = String::from("world");
    let s4 = s3.clone();  // Deep copy\n    println!("{} {}", s3, s4);  // Both valid\n    \n    let x = 5;
    let y = x;  // Copy for primitive types\n    println!("{} {}", x, y);  // Both valid\n}', 'Rust ownership prevents memory errors. Each value has one owner. Move semantics for heap data. Copy trait for stack data. No garbage collector.', 7, 5),
(2, 26, 'Database Index B-Tree', 'CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_composite ON orders(user_id, created_at);
\nEXPLAIN ANALYZE\nSELECT * FROM orders\nWHERE user_id = 123\n  AND created_at >= ''2024-01-01''\nORDER BY created_at;
\n-- Index hints\nSELECT /*+ INDEX(orders idx_orders_composite) */ *\nFROM orders WHERE user_id = 123;', 'Indexes speed up queries using B-trees. Composite indexes for multiple columns. Order matters for range queries. Trade-off: faster reads, slower writes.', 10, 3),
(2, 27, 'C++ RAII Pattern', 'template<typename T>\nclass UniquePtr {
    T* ptr;
public:\n    explicit UniquePtr(T* p = nullptr) : ptr(p) {}
    ~UniquePtr() { delete ptr; }
    UniquePtr(UniquePtr&& other) : ptr(other.ptr) { other.ptr = nullptr; }
    UniquePtr(const UniquePtr&) = delete;
    UniquePtr& operator=(const UniquePtr&) = delete;
    T& operator*() { return *ptr; }
    T* operator->() { return ptr; }
    T* release() { T* p = ptr; ptr = nullptr; return p; }
};', 'RAII ties resource lifetime to object scope. Constructor acquires, destructor releases. No manual cleanup needed. Foundation of modern C++.', 3, 9),
(2, 28, 'MapReduce Concept', 'def map_function(document):\n    for word in document.split():\n        yield (word.lower(), 1)\n\ndef reduce_function(word, counts):\n    return (word, sum(counts))\n\n# Simulation\nfrom collections import defaultdict\nintermediate = defaultdict(list)\nfor doc in documents:\n    for key, value in map_function(doc):\n        intermediate[key].append(value)\n\nresult = []\nfor key in intermediate:\n    result.append(reduce_function(key, intermediate[key]))', 'MapReduce processes big data in parallel. Map transforms data, reduce aggregates. Foundation of Hadoop, Spark. Scales to thousands of machines.', 1, 4),
(2, 29, 'Leap Year Algorithm', '#include <stdbool.h>\nbool is_leap_year(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}
// February 29 exists in leap years\n// Gregorian calendar rule:\n// - Divisible by 4: usually leap\n// - Divisible by 100: usually not leap\n// - Divisible by 400: definitely leap\n// Examples: 2000 (leap), 1900 (not), 2024 (leap)', 'Leap year occurs every 4 years with century exceptions. Compensates for Earth''s 365.25-day orbit. Critical for calendar calculations.', 2, 4);
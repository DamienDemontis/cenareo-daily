-- November Snippets: Data Structures (Complete Month 1-30) - FIXED
INSERT INTO snippets (month, day, title, code, explanation, language_id, category_id) VALUES
(11, 1, 'C Makefile Basics', 'CC=gcc\nCFLAGS=-Wall -Wextra -Werror -std=c99\nSRCS=main.c utils.c\nOBJS=$(SRCS:.c=.o)\nTARGET=program\n\nall: $(TARGET)\n\n$(TARGET): $(OBJS)\n\t$(CC) $(OBJS) -o $@\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\nclean:\n\trm -f $(OBJS)\n\nfclean: clean\n\trm -f $(TARGET)\n\nre: fclean all\n\n.PHONY: all clean fclean re', 'Makefiles automate compilation. Variables make maintenance easier. Pattern rules handle multiple files. Phony targets for commands. Essential for C projects.', 16, 7),
(11, 2, 'Python Error Handling', 'def safe_divide(a, b):\n    try:\n        result = a / b\n        return result\n    except ZeroDivisionError:\n        print("Cannot divide by zero!")\n        return None\n    except TypeError:\n        print("Invalid input types!")\n        return None\n    finally:\n        print("Division operation completed")\n\ntry:\n    with open("data.txt", "r") as file:\n        content = file.read()\nexcept FileNotFoundError:\n    print("File not found!")\nexcept PermissionError:\n    print("No permission to read file!")', 'try-except handles exceptions gracefully. Multiple except blocks catch different errors. finally always executes. Prevents program crashes.', 1, 5),
(11, 3, 'C++ Namespaces', '#include <iostream>\n\nnamespace Math {\n    const double PI = 3.14159;\n    \n    double area_circle(double radius) {\n        return PI * radius * radius;\n    }\n}\n\nnamespace Physics {\n    const double G = 9.81;\n    \n    double kinetic_energy(double mass, double velocity) {\n        return 0.5 * mass * velocity * velocity;\n    }\n}\n\nint main() {\n    std::cout << "Circle area: " << Math::area_circle(5.0) << std::endl;\n    std::cout << "Energy: " << Physics::kinetic_energy(10, 5) << std::endl;\n    return 0;\n}', 'Namespaces organize code and avoid name conflicts. :: scope resolution operator. using namespace can import entire namespace. Prevents naming collisions.', 3, 2),
(11, 4, 'JavaScript Async/Await', 'async function fetchUserData(userId) {\n    try {\n        console.log("Fetching user data...");\n        \n        const userResponse = await fetch(`/api/users/${userId}`);\n        const user = await userResponse.json();\n        \n        const postsResponse = await fetch(`/api/users/${userId}/posts`);\n        const posts = await postsResponse.json();\n        \n        return { user, posts };\n    } catch (error) {\n        console.error("Failed to fetch data:", error);\n        throw error;\n    }\n}\n\n// Usage\nfetchUserData(123).then(data => {\n    console.log(data);\n});', 'async/await simplifies promise handling. await pauses until promise resolves. try/catch for error handling. More readable than promise chains.', 5, 11),
(11, 5, 'C Enum Types', '#include <stdio.h>\n\nenum Status {\n    PENDING = 0,\n    PROCESSING = 1,\n    COMPLETED = 2,\n    ERROR = -1\n};\n\nenum Color { RED, GREEN, BLUE };  // 0, 1, 2\n\nconst char* status_to_string(enum Status s) {\n    switch (s) {\n        case PENDING: return "Pending";\n        case PROCESSING: return "Processing";\n        case COMPLETED: return "Completed";\n        case ERROR: return "Error";\n        default: return "Unknown";\n    }\n}\n\nint main() {\n    enum Status current = PROCESSING;\n    printf("Status: %s\\n", status_to_string(current));\n    return 0;\n}', 'Enums create named integer constants. Values can be explicit or auto-incremented. Improves code readability. Switch statements work well with enums.', 2, 3),
(11, 6, 'Python List Comprehensions', '# Basic list comprehension\nsquares = [x**2 for x in range(10)]\n\n# With condition\nevens = [x for x in range(20) if x % 2 == 0]\n\n# Transform strings\nwords = ["hello", "world", "python"]\nuppercase = [word.upper() for word in words]\n\n# Nested comprehension\nmatrix = [[i*j for j in range(3)] for i in range(3)]\n\n# Dictionary comprehension\nword_lengths = {word: len(word) for word in words}\n\n# Set comprehension\nunique_lengths = {len(word) for word in words}', 'List comprehensions create lists concisely. Syntax: [expression for item in iterable if condition]. More Pythonic than loops. Works with dict/set too.', 1, 3),
(11, 7, 'C++ Overloading', '#include <iostream>\nusing namespace std;\n\nclass Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    double add(double a, double b) {\n        return a + b;\n    }\n    \n    string add(string a, string b) {\n        return a + b;\n    }\n};\n\nint main() {\n    Calculator calc;\n    \n    cout << calc.add(5, 3) << endl;           // int version\n    cout << calc.add(2.5, 1.5) << endl;       // double version\n    cout << calc.add("Hello", " World") << endl; // string version\n    \n    return 0;\n}', 'Function overloading allows same name with different parameters. Compiler chooses based on argument types. Enables intuitive interfaces.', 3, 9),
(11, 8, 'C Linked List Basics', 'struct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* create(int data) {\n    struct Node* node = malloc(sizeof(struct Node));\n    node->data = data;\n    node->next = NULL;\n    return node;\n}\n\nvoid insert_front(struct Node** head, int data) {\n    struct Node* new = create(data);\n    new->next = *head;\n    *head = new;\n}\n\nvoid print_list(struct Node* head) {\n    while (head) {\n        printf("%d ", head->data);\n        head = head->next;\n    }\n}', 'Linked lists store data in nodes. Each node points to next. Dynamic size. insert_front adds to beginning. Pointer to pointer for head modification.', 2, 3),
(11, 9, 'JavaScript Closures', 'function createCounter() {\n    let count = 0;\n    \n    return function() {\n        count++;\n        return count;\n    };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\nconsole.log(counter1()); // 1\nconsole.log(counter1()); // 2\nconsole.log(counter2()); // 1 (separate closure)\n\n// Closure with parameters\nfunction multiplyBy(factor) {\n    return function(number) {\n        return number * factor;\n    };\n}\n\nconst double = multiplyBy(2);\nconsole.log(double(5)); // 10', 'Closures capture variables from outer scope. Inner function remembers outer variables even after outer function returns. Useful for data privacy.', 5, 9),
(11, 10, 'C Advanced String Functions', 'char* my_strstr(const char* hay, const char* needle) {\n    if (!*needle) return (char*)hay;\n    for (; *hay; hay++) {\n        const char *h = hay, *n = needle;\n        while (*h && *n && *h == *n) { h++; n++; }\n        if (!*n) return (char*)hay;\n    }\n    return NULL;\n}\n\nchar* my_strtok(char* str, const char* delim) {\n    static char* next;\n    if (str) next = str;\n    if (!next) return NULL;\n    char* token = next;\n    while (*next && !strchr(delim, *next)) next++;\n    if (*next) *next++ = ''\\0'';\n    return token;\n}', 'String search algorithms. strstr finds substring. strtok splits by delimiter. Static variables maintain state between calls. Understanding pointers crucial.', 2, 4),
(11, 11, 'C++ String Class Features', '#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring s = "Hello World";\n// Find substring\nsize_t pos = s.find("World");  // Returns 6\n// Replace\ns.replace(6, 5, "C++");  // "Hello C++"\n// Substring\nstring sub = s.substr(0, 5);  // "Hello"\n// Transform\ntransform(s.begin(), s.end(), s.begin(), ::tolower);\n// Trim spaces\ns.erase(0, s.find_first_not_of(" \\t"));\ns.erase(s.find_last_not_of(" \\t") + 1);', 'C++ string class provides rich functionality. find(), replace(), substr() for manipulation. STL algorithms work on strings. Much safer than C strings.', 3, 3),
(11, 12, 'Regular Expression Basics', '#include <regex.h>\nint main() {\n    regex_t regex;\n    // Compile pattern\n    regcomp(&regex, "^[a-zA-Z0-9]+@[a-z]+\\.[a-z]+$", REG_EXTENDED);\n    \n    // Match string\n    int result = regexec(&regex, "user@email.com", 0, NULL, 0);\n    if (result == 0) {\n        printf("Valid email\\n");\n    } else if (result == REG_NOMATCH) {\n        printf("Invalid email\\n");\n    }\n    \n    regfree(&regex);\n    return 0;\n}', 'Regular expressions match patterns in text. Compile pattern once, use multiple times. Powerful for validation, parsing. Clean up with regfree().', 2, 4),
(11, 13, 'C Stack Data Structure', 'typedef struct {\n    int* items;\n    int top;\n    int capacity;\n} Stack;\n\nStack* create_stack(int cap) {\n    Stack* s = malloc(sizeof(Stack));\n    s->items = malloc(cap * sizeof(int));\n    s->top = -1;\n    s->capacity = cap;\n    return s;\n}\n\nvoid push(Stack* s, int item) {\n    if (s->top < s->capacity - 1)\n        s->items[++s->top] = item;\n}\n\nint pop(Stack* s) {\n    return (s->top >= 0) ? s->items[s->top--] : -1;\n}', 'Stack follows LIFO (Last In, First Out). Array-based implementation. Check bounds to prevent overflow/underflow. Essential for recursion, parsing.', 2, 3),
(11, 14, 'Python Decorators', 'import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f"{func.__name__} took {end-start:.4f} seconds")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(1)\n    return "Done"\n\n# Decorator with parameters\ndef repeat(times):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                func(*args, **kwargs)\n        return wrapper\n    return decorator', 'Decorators modify function behavior without changing code. @syntax applies decorator. functools.wraps preserves function metadata. Powerful metaprogramming tool.', 1, 9),
(11, 15, 'C++ Map Container', '#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, int> scores;\n// Insert\nscores["Alice"] = 95;\nscores.insert({"Bob", 87});\n\n// Access\nint alice = scores["Alice"];\nint charlie = scores["Charlie"];  // Creates with 0\n\n// Check existence\nif (scores.find("David") != scores.end()) {\n    cout << "Found David\\n";\n}\n\n// Iterate\nfor (const auto& [name, score] : scores) {\n    cout << name << ": " << score << "\\n";\n}', 'std::map stores sorted key-value pairs. Red-black tree implementation. O(log n) operations. Auto-creates entries with default values.', 3, 3),
(11, 16, 'C Queue Data Structure', 'typedef struct {\n    int* items;\n    int front, rear, size, capacity;\n} Queue;\n\nQueue* create_queue(int cap) {\n    Queue* q = malloc(sizeof(Queue));\n    q->items = malloc(cap * sizeof(int));\n    q->front = q->size = 0;\n    q->rear = cap - 1;\n    q->capacity = cap;\n    return q;\n}\n\nvoid enqueue(Queue* q, int item) {\n    if (q->size == q->capacity) return;\n    q->rear = (q->rear + 1) % q->capacity;\n    q->items[q->rear] = item;\n    q->size++;\n}\n\nint dequeue(Queue* q) {\n    if (q->size == 0) return -1;\n    int item = q->items[q->front];\n    q->front = (q->front + 1) % q->capacity;\n    q->size--;\n    return item;\n}', 'Queue follows FIFO (First In, First Out). Circular array implementation. Modulo arithmetic wraps indices. Used in scheduling, breadth-first search.', 2, 3),
(11, 17, 'Node.js HTTP Server', 'const http = require(''http'');\nconst url = require(''url'');\n\nconst server = http.createServer((req, res) => {\n    const parsed = url.parse(req.url, true);\n    \n    if (parsed.pathname === ''/api/hello'') {\n        res.writeHead(200, {''Content-Type'': ''application/json''});\n        res.end(JSON.stringify({message: ''Hello Epitech!''}));\n    } else {\n        res.writeHead(404);\n        res.end(''Not Found'');\n    }\n});\n\nserver.listen(3000, () => {\n    console.log(''Server running on port 3000'');\n});', 'Node.js creates HTTP servers easily. Parse URLs to route requests. Set headers and status codes. JSON API endpoints. Event-driven, non-blocking I/O.', 5, 11),
(11, 18, 'C Bubble Sort Algorithm', 'void bubble_sort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        int swapped = 0;\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                swapped = 1;\n            }\n        }\n        if (!swapped) break;  // Already sorted\n    }\n}', 'Bubble sort compares adjacent elements. Swaps if wrong order. Optimization: stop if no swaps (already sorted). O(nÂ²) complexity. Good for learning.', 2, 4),
(11, 19, 'Python CSV File Processing', 'import csv\n\n# Write CSV\nwith open(''data.csv'', ''w'', newline='''') as file:\n    writer = csv.writer(file)\n    writer.writerow([''Name'', ''Age'', ''City''])\n    writer.writerow([''Alice'', 25, ''Paris''])\n\n# Read CSV\nwith open(''data.csv'', ''r'') as file:\n    reader = csv.DictReader(file)\n    for row in reader:\n        print(f"{row[''Name'']}: {row[''Age'']}")\n\n# Write dictionary\nwith open(''output.csv'', ''w'') as file:\n    fieldnames = [''name'', ''score'']\n    writer = csv.DictWriter(file, fieldnames=fieldnames)\n    writer.writeheader()\n    writer.writerow({''name'': ''Bob'', ''score'': 95})', 'CSV module handles comma-separated values. DictReader/DictWriter use column names. Handle headers automatically. Common data exchange format.', 1, 5),
(11, 20, 'C++ Vector Advanced Operations', '#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> v = {3, 1, 4, 1, 5};\n\n// Sort\nsort(v.begin(), v.end());\n\n// Binary search (must be sorted)\nbool found = binary_search(v.begin(), v.end(), 4);\n\n// Remove duplicates\nv.erase(unique(v.begin(), v.end()), v.end());\n\n// Partition\nauto pivot = partition(v.begin(), v.end(),\n    [](int x) { return x < 3; });\n\n// Transform\ntransform(v.begin(), v.end(), v.begin(),\n    [](int x) { return x * 2; });', 'STL algorithms work on vectors. sort() rearranges elements. unique() removes consecutive duplicates. partition() reorders by predicate.', 3, 3),
(11, 21, 'C Preprocessor Macros', '#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define ARRAY_SIZE(arr) (sizeof(arr)/sizeof(arr[0]))\n#define SWAP(a,b) do { typeof(a) _t = a; a = b; b = _t; } while(0)\n\nint main() {\n    int x = 5, y = 10;\n    printf("Max: %d\\n", MAX(x, y));\n    SWAP(x, y);\n    printf("After swap: x=%d, y=%d\\n", x, y);\n    \n    int arr[] = {1, 2, 3, 4, 5};\n    printf("Array size: %zu\\n", ARRAY_SIZE(arr));\n}', 'Macros provide code substitution. Parentheses prevent precedence issues. do-while for multi-statement safety. typeof for generic code (GCC).', 2, 2),
(11, 22, 'Python Decorators', 'def memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args in cache:\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(100))  # Fast with memoization', 'Decorators modify function behavior. @ syntax applies decorator. Closure captures cache. Memoization stores results. Dramatic performance improvement.', 1, 9),
(11, 23, 'C Signal Handling', '#include <signal.h>\n#include <stdio.h>\n#include <unistd.h>\n\nvolatile sig_atomic_t running = 1;\n\nvoid handle_sigint(int sig) {\n    printf("\\nReceived signal %d, stopping...\\n", sig);\n    running = 0;\n}\n\nint main() {\n    signal(SIGINT, handle_sigint);\n    \n    while (running) {\n        printf("Working...\\n");\n        sleep(1);\n    }\n    \n    printf("Cleanup complete\\n");\n    return 0;\n}', 'Signals enable async communication. SIGINT from Ctrl+C. Handler must be async-safe. volatile for shared variables. Graceful shutdown pattern.', 2, 6),
(11, 24, 'C++ Template Functions', 'template <typename T>\nT max(T a, T b) {\n    return (a > b) ? a : b;\n}\n\ntemplate <typename T>\nvoid swap(T& a, T& b) {\n    T temp = a;\n    a = b;\n    b = temp;\n}\n\ntemplate <typename T, size_t N>\nsize_t array_size(T (&)[N]) {\n    return N;\n}\n\nint main() {\n    int x = max(3, 7);          // int version\n    double y = max(3.14, 2.71); // double version\n}', 'Templates generate code for multiple types. Compiler deduces types. Zero runtime overhead. Type-safe generics. Compile-time polymorphism.', 3, 9),
(11, 25, 'SQL Basics', 'CREATE TABLE students (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    age INT CHECK (age >= 18),\n    email VARCHAR(255) UNIQUE\n);\n\nINSERT INTO students (name, age, email)\nVALUES (''Alice'', 20, ''alice@epitech.eu'');\n\nSELECT name, age \nFROM students \nWHERE age > 18 \nORDER BY name;\n\nUPDATE students SET age = 21 WHERE id = 1;\nDELETE FROM students WHERE email IS NULL;', 'SQL manages relational data. CREATE defines structure. Constraints ensure integrity. CRUD operations: Create, Read, Update, Delete.', 10, 3),
(11, 26, 'JavaScript Promises', 'function delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function fetchData() {\n    try {\n        console.log("Fetching...");\n        await delay(1000);\n        const data = await fetch(''/api/data'');\n        const json = await data.json();\n        return json;\n    } catch (error) {\n        console.error("Error:", error);\n        throw error;\n    }\n}\n\nfetchData().then(data => console.log(data));', 'Promises handle async operations. async/await simplifies syntax. try/catch for errors. Chain with then(). Better than callbacks.', 5, 11),
(11, 27, 'C Dynamic Memory', '#include <stdlib.h>\n#include <string.h>\n\nchar* duplicate_string(const char* src) {\n    if (!src) return NULL;\n    \n    size_t len = strlen(src) + 1;\n    char* copy = malloc(len);\n    if (!copy) return NULL;\n    \n    strcpy(copy, src);\n    return copy;\n}\n\nint main() {\n    char* str = duplicate_string("Hello");\n    if (str) {\n        printf("%s\\n", str);\n        free(str);\n    }\n}', 'Dynamic allocation for runtime sizing. Check malloc return. Match malloc/free pairs. Calculate size carefully. Handle allocation failures.', 2, 5),
(11, 28, 'Python Comprehensions', '# List comprehension\nsquares = [x**2 for x in range(10) if x % 2 == 0]\n\n# Dict comprehension\nword_len = {word: len(word) for word in ["hi", "hello", "bye"]}\n\n# Set comprehension\nunique = {x % 10 for x in range(100)}\n\n# Generator expression\nsum_squares = sum(x**2 for x in range(1000000))\n\n# Nested comprehension\nmatrix = [[i*j for j in range(3)] for i in range(3)]', 'Comprehensions create collections concisely. Filter with if clause. Generators save memory. Nested for matrices. Pythonic and efficient.', 1, 3),
(11, 29, 'C Hash Table Implementation', '#define TABLE_SIZE 100\n\ntypedef struct Entry {\n    char* key;\n    int value;\n    struct Entry* next;\n} Entry;\n\ntypedef struct {\n    Entry* buckets[TABLE_SIZE];\n} HashTable;\n\nunsigned int hash(const char* key) {\n    unsigned int hash = 5381;\n    int c;\n    while ((c = *key++)) hash = ((hash << 5) + hash) + c;\n    return hash % TABLE_SIZE;\n}\n\nvoid insert(HashTable* ht, const char* key, int value) {\n    unsigned int index = hash(key);\n    Entry* entry = malloc(sizeof(Entry));\n    entry->key = strdup(key);\n    entry->value = value;\n    entry->next = ht->buckets[index];\n    ht->buckets[index] = entry;\n}', 'Hash tables provide O(1) average lookup. Hash function maps keys to indices. Collision handling with chaining. djb2 algorithm for string hashing.', 2, 3),
(11, 30, 'C Binary Search Algorithm', 'int binary_search(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (arr[mid] == target)\n            return mid;\n        \n        if (arr[mid] < target)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n    \n    return -1;  // Not found\n}', 'Binary search requires sorted array. Divides search space in half each iteration. O(log n) time complexity. Efficient for large datasets.', 2, 4);
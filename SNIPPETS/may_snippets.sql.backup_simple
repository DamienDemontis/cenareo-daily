-- May Snippets: Network Programming & Security
INSERT INTO snippets (month, day, title, code, explanation, language_id, category_id) VALUES
(5, 1, 'TCP Socket Server', '#include <sys/socket.h>\n#include <netinet/in.h>\nint main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = INADDR_ANY;
    bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
    listen(server_fd, 3);
    int client = accept(server_fd, NULL, NULL);
    send(client, "Hello\\n", 6, 0);
}', 'TCP server basics: socket creates endpoint, bind assigns address, listen enables connections, accept waits for client. Foundation of network services.', 2, 11),
(5, 2, 'UDP Socket Communication', '#include <sys/socket.h>\nint main() {
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);
    \n    char* msg = "UDP message";
    sendto(sock, msg, strlen(msg), 0,\n           (struct sockaddr*)&addr, sizeof(addr));
    \n    char buffer[1024];
    recvfrom(sock, buffer, 1024, 0, NULL, NULL);
}', 'UDP is connectionless protocol. No handshake, lower overhead. sendto/recvfrom for datagrams. Fast but unreliable. Good for streaming, games.', 2, 11),
(5, 3, 'HTTP Client Request', 'import requests\nimport json\n\n# GET request\nresponse = requests.get("https://api.github.com/users/torvalds")\ndata = response.json()\n\n# POST with headers\nheaders = {"Authorization": "Bearer token",\n           "Content-Type": "application/json"}
payload = {"name": "test", "value": 42}
response = requests.post("https://api.example.com/data",\n                        json=payload, headers=headers)\n\n# Session for cookies\nsession = requests.Session()\nsession.post("/login", data={"user": "admin"})', 'HTTP client using requests library. GET fetches, POST sends data. Headers for auth, content type. Sessions maintain cookies.', 1, 11),
(5, 4, 'Buffer Overflow Protection', '#include <string.h>\nvoid vulnerable(char* input) {
    char buffer[64];
    strcpy(buffer, input);  // BAD: No bounds check\n}
\nvoid safe(char* input) {
    char buffer[64];
    strncpy(buffer, input, sizeof(buffer)-1);
    buffer[sizeof(buffer)-1] = ''\\0'';
    // Or use strlcpy, snprintf\n}
\n// Compile with: gcc -fstack-protector -D_FORTIFY_SOURCE=2\n// Enable ASLR, DEP/NX bit', 'Buffer overflows exploit memory corruption. Use bounded functions. Stack canaries detect overflows. ASLR randomizes addresses. Never trust input size.', 2, 8),
(5, 5, 'Password Hashing', 'import bcrypt\nimport secrets\n\ndef hash_password(password):\n    # Generate salt and hash\n    salt = bcrypt.gensalt(rounds=12)\n    hashed = bcrypt.hashpw(password.encode(''utf-8''), salt)\n    return hashed\n\ndef verify_password(password, hashed):\n    return bcrypt.checkpw(password.encode(''utf-8''), hashed)\n\n# Generate secure tokens\ntoken = secrets.token_urlsafe(32)\napi_key = secrets.token_hex(16)', 'Never store plain passwords. bcrypt adds salt, slow by design. Prevents rainbow tables, brute force. secrets for cryptographic randomness.', 1, 8),
(5, 6, 'SQL Injection Prevention', '# VULNERABLE - Never do this!\nsql = f"SELECT * FROM users WHERE name = ''{name}''";
\n# SAFE - Parameterized queries\ncursor.execute(\n    "SELECT * FROM users WHERE name = ? AND age > ?",\n    (name, age)\n)\n\n# SAFE - Prepared statements\nstmt = connection.prepare(\n    "INSERT INTO logs (user, action) VALUES ($1, $2)"\n)\nstmt.execute(user_id, action)\n\n# Validate/escape input\nname = re.sub(r''[^a-zA-Z0-9]'', '''', name)', 'SQL injection exploits string concatenation. Use parameterized queries. Prepared statements separate data from code. Never trust user input.', 1, 8),
(5, 7, 'HTTPS/TLS Setup', '#include <openssl/ssl.h>\nSSL_CTX* create_context() {
    SSL_library_init();
    SSL_CTX* ctx = SSL_CTX_new(TLS_server_method());
    \n    // Load certificate and private key\n    SSL_CTX_use_certificate_file(ctx, "cert.pem", SSL_FILETYPE_PEM);
    SSL_CTX_use_PrivateKey_file(ctx, "key.pem", SSL_FILETYPE_PEM);
    \n    // Set cipher suites\n    SSL_CTX_set_cipher_list(ctx,\n        "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256");
    \n    return ctx;
}', 'TLS encrypts network traffic. OpenSSL provides implementation. Certificates verify identity. Modern ciphers prevent attacks. HTTPS essential for web.', 2, 8),
(5, 8, 'WebSocket Protocol', 'import asyncio\nimport websockets\n\nasync def echo(websocket, path):\n    async for message in websocket:\n        await websocket.send(f"Echo: {message}")\n\nasync def main():\n    async with websockets.serve(echo, "localhost", 8765):\n        await asyncio.Future()  # Run forever\n\n# Client\nasync def client():\n    async with websockets.connect("ws://localhost:8765") as ws:\n        await ws.send("Hello")\n        response = await ws.recv()', 'WebSockets provide full-duplex communication. Persistent connection over HTTP. Real-time bidirectional data. Used in chat, live updates.', 1, 11),
(5, 9, 'Cross-Site Scripting (XSS)', '// VULNERABLE\ndocument.getElementById("output").innerHTML = userInput;
\n// SAFE - Escape HTML\nfunction escapeHtml(text) {
    const map = {
        ''&'': ''&amp;'', ''<'': ''&lt;'', ''>'': ''&gt;'',\n        ''"'': ''&quot;'', "''": ''&#039;''\n    };
    return text.replace(/[&<>"'']/g, m => map[m]);
}
element.textContent = userInput;  // Safe\nelement.innerHTML = escapeHtml(userInput);
\n// Content Security Policy\n// <meta http-equiv="Content-Security-Policy"\n//       content="default-src ''self'';">', 'XSS injects malicious scripts. Escape user content. Use textContent not innerHTML. CSP headers prevent inline scripts. Validate all input.', 5, 8),
(5, 10, 'JWT Authentication', 'const jwt = require(''jsonwebtoken'');
\n// Generate token\nfunction generateToken(user) {
    return jwt.sign(\n        { id: user.id, email: user.email },\n        process.env.JWT_SECRET,\n        { expiresIn: ''1h'', algorithm: ''HS256'' }
    );
}
\n// Verify token\nfunction verifyToken(token) {
    try {
        return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
        throw new Error(''Invalid token'');
    }
}', 'JWT enables stateless authentication. Header.Payload.Signature structure. Sign with secret key. Include expiration. Never store sensitive data.', 5, 8),
(5, 11, 'Port Scanning', '#include <sys/socket.h>\n#include <netinet/in.h>\n#include <fcntl.h>\nint scan_port(const char* host, int port) {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    fcntl(sock, F_SETFL, O_NONBLOCK);
    \n    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    inet_pton(AF_INET, host, &addr.sin_addr);
    \n    int result = connect(sock, (struct sockaddr*)&addr, sizeof(addr));
    close(sock);
    return (result == 0) ? 1 : 0;
}', 'Port scanning checks open services. Non-blocking sockets for speed. Used for security audits. Respect rate limits, get permission.', 2, 11),
(5, 12, 'CORS Configuration', 'const cors = require(''cors'');
\n// Allow specific origins\nconst corsOptions = {
    origin: [''https://trusted-site.com''],\n    credentials: true,\n    methods: [''GET'', ''POST''],\n    allowedHeaders: [''Content-Type'', ''Authorization''],\n    maxAge: 86400  // Cache preflight\n};
\napp.use(cors(corsOptions));
\n// Manual headers\nres.setHeader(''Access-Control-Allow-Origin'', ''*'');
res.setHeader(''Access-Control-Allow-Methods'', ''GET, POST'');', 'CORS controls cross-origin requests. Prevents unauthorized API access. Whitelist trusted origins. Credentials require specific origin. Security boundary.', 5, 8),
(5, 13, 'Rate Limiting', 'from functools import wraps\nimport time\n\nclass RateLimiter:\n    def __init__(self, max_calls, period):\n        self.max_calls = max_calls\n        self.period = period\n        self.calls = {}
    \n    def __call__(self, func):\n        @wraps(func)\n        def wrapper(request, *args):\n            now = time.time()\n            key = request.remote_addr\n            \n            if key not in self.calls:\n                self.calls[key] = []\n            \n            # Remove old calls\n            self.calls[key] = [t for t in self.calls[key] if now - t < self.period]\n            \n            if len(self.calls[key]) >= self.max_calls:\n                return "Rate limit exceeded", 429\n            \n            self.calls[key].append(now)\n            return func(request, *args)', 'Rate limiting prevents abuse. Track requests per IP/user. Sliding window algorithm. Return 429 when exceeded. Essential protection.', 1, 8),
(5, 14, 'Encryption AES', '#include <openssl/aes.h>\nvoid encrypt_AES(unsigned char* plaintext, unsigned char* key,\n                 unsigned char* ciphertext) {
    AES_KEY aes_key;
    AES_set_encrypt_key(key, 128, &aes_key);
    \n    unsigned char iv[AES_BLOCK_SIZE];
    RAND_bytes(iv, AES_BLOCK_SIZE);  // Random IV\n    \n    // CBC mode encryption\n    AES_cbc_encrypt(plaintext, ciphertext,\n                    strlen((char*)plaintext),\n                    &aes_key, iv, AES_ENCRYPT);
}
// Use authenticated encryption (AES-GCM) in production', 'AES symmetric encryption. 128/256-bit keys. CBC mode with random IV. Never reuse IV. Use authenticated encryption (AEAD) when possible.', 2, 8),
(5, 15, 'OAuth2 Flow', 'import requests\n\n# Authorization Code Flow\ndef get_auth_url(client_id, redirect_uri):\n    return (\n        f"https://oauth.provider.com/authorize?"\n        f"client_id={client_id}&"\n        f"redirect_uri={redirect_uri}&"\n        f"response_type=code&"\n        f"scope=read:user"\n    )\n\ndef exchange_code(code, client_id, client_secret):\n    response = requests.post(\n        "https://oauth.provider.com/token",\n        data={
            "grant_type": "authorization_code",\n            "code": code,\n            "client_id": client_id,\n            "client_secret": client_secret\n        }
    )\n    return response.json()["access_token"]', 'OAuth2 delegates authentication. Authorization code flow most secure. Exchange code for token. Never expose client secret. Use PKCE for public clients.', 1, 8),
(5, 16, 'DNS Resolution', '#include <netdb.h>\n#include <arpa/inet.h>\nvoid resolve_hostname(const char* hostname) {
    struct hostent* host = gethostbyname(hostname);
    if (host) {
        printf("Official name: %s\\n", host->h_name);\n        for (int i = 0; host->h_addr_list[i]; i++) {\n            struct in_addr addr;\n            addr.s_addr = *((unsigned long*)host->h_addr_list[i]);
            printf("IP: %s\\n", inet_ntoa(addr));\n        }\n    }\n    // Modern: use getaddrinfo() for IPv6 support\n}', 'DNS resolves hostnames to IPs. gethostbyname legacy, getaddrinfo modern. Supports multiple IPs. Cache results. Handle failures gracefully.', 2, 11),
(5, 17, 'Firewall Rules', '#!/bin/bash\n# iptables firewall configuration\n\n# Default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow established connections\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n\n# Allow localhost\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow SSH from specific IP\niptables -A INPUT -p tcp --dport 22 -s 192.168.1.100 -j ACCEPT\n\n# Allow HTTP/HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT', 'Firewall controls network traffic. Default deny, whitelist allowed. Stateful tracking. Rate limiting possible. Essential security layer.', 14, 8),
(5, 18, 'Content Security Policy', 'const helmet = require(''helmet'');
\napp.use(helmet.contentSecurityPolicy({
    directives: {
        defaultSrc: ["''self''"],\n        scriptSrc: ["''self''", "''unsafe-inline''", "cdn.trusted.com"],\n        styleSrc: ["''self''", "''unsafe-inline''"],\n        imgSrc: ["''self''", "data:", "https:"],\n        connectSrc: ["''self''", "api.example.com"],\n        fontSrc: ["''self''", "fonts.googleapis.com"],\n        objectSrc: ["''none''"],\n        upgradeInsecureRequests: [],\n    },\n    reportOnly: false\n}));', 'CSP prevents XSS attacks. Whitelist content sources. Block inline scripts. Report violations. Start report-only, then enforce. Modern security standard.', 5, 8),
(5, 19, 'SSH Key Authentication', '#!/bin/bash\n# Generate SSH key pair\nssh-keygen -t ed25519 -C "email@example.com"\n\n# Copy public key to server
ssh-copy-id user@server\n\n# SSH config (~/.ssh/config)\nHost myserver\n    HostName 192.168.1.10\n    User admin\n    Port 2222\n    IdentityFile ~/.ssh/id_ed25519\n    ForwardAgent yes\n\n# Disable password auth (server)\n# /etc/ssh/sshd_config:\n# PasswordAuthentication no\n# PubkeyAuthentication yes', 'SSH keys more secure than passwords. Ed25519 modern algorithm. Agent forwarding for chaining. Config simplifies connections. Disable password auth.', 14, 8),
(5, 20, 'Load Balancing', 'http {
    upstream backend {
        least_conn;  # or ip_hash, random\n        server backend1.example.com:8080 weight=3;
        server backend2.example.com:8080 weight=1;
        server backend3.example.com:8080 backup;
        \n        keepalive 32;  # Connection pooling\n    }
    \n    server {
        listen 80;
        location / {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}', 'Load balancers distribute traffic. Round-robin, least connections, IP hash. Health checks detect failures. Sticky sessions when needed. Scales horizontally.', 15, 11),
(5, 21, 'Certificate Pinning', 'import ssl\nimport hashlib\n\ndef verify_cert_pin(cert_der, expected_pin):\n    # Calculate SHA256 of certificate\n    cert_hash = hashlib.sha256(cert_der).digest()\n    pin = base64.b64encode(cert_hash).decode()\n    \n    if pin != expected_pin:\n        raise ssl.SSLError("Certificate pin mismatch")\n\n# Android (Network Security Config)\n# <pin-set expiration="2025-01-01">\n#   <pin digest="SHA-256">base64hash==</pin>\n# </pin-set>\n\n# iOS (Info.plist)\n# NSPinnedDomains -> domain -> NSPinnedCAIdentities', 'Certificate pinning prevents MITM attacks. Hardcode expected certificate hash. Update before expiration. Backup pins recommended. Mobile apps critical.', 1, 8),
(5, 22, 'GraphQL Security', 'const depthLimit = require(''graphql-depth-limit'');
const costAnalysis = require(''graphql-cost-analysis'');
\nconst server = new GraphQLServer({
    validationRules: [\n        depthLimit(5),  // Max query depth\n        costAnalysis({
            maximumCost: 1000,\n            defaultCost: 1,\n            variables: {},\n            createError: (max, actual) => {
                return new Error(`Query cost ${actual} exceeds ${max}`);
            }
        })\n    ],\n    // Disable introspection in production\n    introspection: process.env.NODE_ENV !== ''production''
});', 'GraphQL needs special security. Limit query depth, complexity. Calculate query cost. Disable introspection. Rate limit by complexity. Prevent DoS.', 5, 8),
(5, 23, 'Zero Trust Network', 'class ZeroTrustGateway:\n    def authenticate(self, request):\n        # Verify device identity\n        device_cert = request.client_cert\n        if not self.verify_device(device_cert):\n            return False\n        \n        # Verify user identity\n        token = request.headers.get(''Authorization'')\n        user = self.verify_token(token)\n        if not user:\n            return False\n        \n        # Check authorization for resource\n        if not self.authorize(user, request.path):\n            return False\n        \n        # Log access for audit\n        self.audit_log(user, request)\n        return True\n\n# Never trust, always verify', 'Zero trust assumes breach. Verify every request. Device and user authentication. Least privilege access. Continuous verification. Modern security model.', 1, 8),
(5, 24, 'API Gateway', 'const express = require(''express'');
const httpProxy = require(''http-proxy-middleware'');
\nconst app = express();
\n// Rate limiting\napp.use(rateLimit({ windowMs: 60000, max: 100 }));
\n// Authentication\napp.use(authenticateToken);
\n// Route to microservices\napp.use(''/users'', httpProxy({
    target: ''http://user-service:3001'',\n    changeOrigin: true\n}));
\napp.use(''/orders'', httpProxy({
    target: ''http://order-service:3002'',\n    changeOrigin: true,\n    pathRewrite: { ''^/orders'': ''/api/v1/orders'' }
}));', 'API gateway centralizes access. Authentication, rate limiting, routing. Simplifies clients. Circuit breaking, caching possible. Microservices pattern.', 5, 11),
(5, 25, 'Network Packet Capture', '#include <pcap.h>\nvoid packet_handler(u_char* user, const struct pcap_pkthdr* h,\n                   const u_char* packet) {
    struct ether_header* eth = (struct ether_header*)packet;
    if (ntohs(eth->ether_type) == ETHERTYPE_IP) {
        struct ip* ip_hdr = (struct ip*)(packet + sizeof(*eth));
        printf("IP: %s -> ", inet_ntoa(ip_hdr->ip_src));\n        printf("%s\\n", inet_ntoa(ip_hdr->ip_dst));\n    }\n}\nint main() {\n    pcap_t* handle = pcap_open_live("eth0", BUFSIZ, 1, 1000, NULL);
    pcap_loop(handle, -1, packet_handler, NULL);
}', 'Packet capture analyzes network traffic. libpcap foundation of tcpdump, Wireshark. Parse protocol headers. Requires root/admin. Debugging, security analysis.', 2, 11),
(5, 26, 'Secure Random', '#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nvoid secure_random(void* buffer, size_t size) {
    int fd = open("/dev/urandom", O_RDONLY);
    if (fd < 0) {
        perror("Cannot open /dev/urandom");
        exit(1);
    }
    if (read(fd, buffer, size) != size) {
        fprintf(stderr, "Failed to read random bytes\\n");\n        exit(1);\n    }\n    close(fd);\n}\n// Windows: use CryptGenRandom\n// Modern C++: std::random_device', 'Cryptographic randomness essential for security. /dev/urandom on Unix. Never use rand() for security. Seeds, tokens, nonces, IVs.', 2, 8),
(5, 27, 'MQTT Protocol', 'import paho.mqtt.client as mqtt\n\ndef on_connect(client, userdata, flags, rc):\n    print(f"Connected with result code {rc}")\n    client.subscribe("sensors/temperature")\n\ndef on_message(client, userdata, msg):\n    print(f"{msg.topic}: {msg.payload.decode()}")\n\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nclient.tls_set()  # Enable TLS\nclient.username_pw_set("user", "pass")\nclient.connect("mqtt.broker.com", 8883)\n\nclient.publish("sensors/humidity", "45%", qos=1)\nclient.loop_forever()', 'MQTT lightweight pub/sub protocol. QoS levels: 0 (at most once), 1 (at least once), 2 (exactly once). IoT standard. Broker manages messages.', 1, 11),
(5, 28, 'Secure Headers', 'app.use((req, res, next) => {
    // Security headers\n    res.setHeader(''X-Frame-Options'', ''DENY'');
    res.setHeader(''X-Content-Type-Options'', ''nosniff'');
    res.setHeader(''X-XSS-Protection'', ''1; mode=block'');
    res.setHeader(''Strict-Transport-Security'',\n                  ''max-age=31536000; includeSubDomains'');
    res.setHeader(''Referrer-Policy'', ''strict-origin-when-cross-origin'');
    res.setHeader(''Permissions-Policy'',\n                  ''geolocation=(), microphone=(), camera=()'');
    \n    // Remove sensitive headers\n    res.removeHeader(''X-Powered-By'');
    next();
});', 'Security headers prevent attacks. X-Frame stops clickjacking. HSTS forces HTTPS. CSP prevents XSS. Hide server info. Defense in depth.', 5, 8),
(5, 29, 'VPN Tunneling', '#!/bin/bash\n# OpenVPN client configuration\ncat > client.ovpn << EOF\nclient\ndev tun\nproto udp\nremote vpn.server.com 1194\nresolv-retry infinite\nnobind\npersist-key\npersist-tun\nca ca.crt\ncert client.crt\nkey client.key\ncipher AES-256-GCM\nauth SHA256\ncomp-lzo\nverb 3\nEOF\n\n# Connect\nsudo openvpn --config client.ovpn\n\n# WireGuard (modern alternative)\nwg-quick up wg0', 'VPN creates secure tunnel. Encrypts all traffic. Hides real IP. OpenVPN widely supported. WireGuard faster, simpler. Corporate/privacy use.', 14, 11),
(5, 30, 'Input Validation', 'import re\nfrom typing import Optional\n\nclass Validator:\n    @staticmethod\n    def email(email: str) -> bool:\n        pattern = r''^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$''\n        return bool(re.match(pattern, email))\n    \n    @staticmethod\n    def sanitize_html(text: str) -> str:\n        # Remove all HTML tags\n        return re.sub(r''<[^>]+>'', '''', text)\n    \n    @staticmethod
    def validate_input(data: dict, rules: dict) -> tuple:\n        errors = {}
        for field, rule in rules.items():\n            if field not in data:\n                errors[field] = "Required"\n            elif not rule(data[field]):\n                errors[field] = "Invalid"\n        return len(errors) == 0, errors', 'Input validation prevents injection attacks. Whitelist acceptable input. Sanitize user data. Regular expressions for patterns. Never trust user input.', 1, 8),
(5, 31, 'Network Monitoring', 'import psutil\nimport socket\n\ndef monitor_connections():\n    connections = psutil.net_connections()\n    for conn in connections:\n        if conn.status == ''ESTABLISHED'':\n            try:\n                remote_ip = conn.raddr.ip\n                remote_port = conn.raddr.port\n                local_port = conn.laddr.port\n                pid = conn.pid\n                process = psutil.Process(pid).name()\n                \n                print(f"{process}({pid}): "\n                      f"{local_port} -> {remote_ip}:{remote_port}")\n            except:\n                pass\n\n# Network statistics\nstats = psutil.net_io_counters()\nprint(f"Bytes sent: {stats.bytes_sent:,}")\nprint(f"Bytes recv: {stats.bytes_recv:,}")', 'Monitor network connections and traffic. Detect suspicious activity. Track bandwidth usage. Identify processes. Security and performance analysis.', 1, 11);
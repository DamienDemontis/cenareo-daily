-- March Snippets: Object-Oriented & Design Patterns
INSERT INTO snippets (month, day, title, code, explanation, language_id, category_id) VALUES
(3, 1, 'Singleton Pattern', 'class Singleton {\nprivate:\n    static Singleton* instance;\n    Singleton() {}\npublic:\n    static Singleton* getInstance() {\n        if (!instance) instance = new Singleton();\n        return instance;\n    }\n    Singleton(const Singleton&) = delete;\n    void operator=(const Singleton&) = delete;\n};\nSingleton* Singleton::instance = nullptr;', 'Singleton ensures single instance. Private constructor prevents direct creation. Static method controls access. Used for configs, loggers.', 3, 9),
(3, 2, 'Factory Pattern', 'class ShapeFactory {\npublic:\n    enum ShapeType { CIRCLE, SQUARE, TRIANGLE };\n    static unique_ptr<Shape> createShape(ShapeType type) {\n        switch(type) {\n            case CIRCLE: return make_unique<Circle>();\n            case SQUARE: return make_unique<Square>();\n            case TRIANGLE: return make_unique<Triangle>();\n        }\n        return nullptr;\n    }\n};', 'Factory pattern creates objects without specifying exact class. Encapsulates object creation logic. Enables loose coupling and flexibility.', 3, 9),
(3, 3, 'Observer Pattern', 'class Subject {\n    vector<Observer*> observers;\npublic:\n    void attach(Observer* obs) { observers.push_back(obs); }\n    void detach(Observer* obs) {\n        observers.erase(remove(observers.begin(), observers.end(), obs));\n    }\n    void notify() {\n        for (auto obs : observers) obs->update(this);\n    }\n};', 'Observer defines one-to-many dependency. Subjects notify observers of changes. Used in MVC, event systems, reactive programming.', 3, 9),
(3, 4, 'Python Class Inheritance', 'class Animal:\n    def __init__(self, name):\n        self.name = name\n    def speak(self):\n        raise NotImplementedError\n\nclass Dog(Animal):\n    def speak(self):\n        return f"{self.name} says Woof!"\n\nclass Cat(Animal):\n    def speak(self):\n        return f"{self.name} says Meow!"\n\nanimals = [Dog("Rex"), Cat("Whiskers")]\nfor animal in animals:\n    print(animal.speak())', 'Inheritance creates is-a relationships. Child classes extend parent. Polymorphism allows uniform interface. Override methods for specialization.', 1, 9),
(3, 5, 'Virtual Functions C++', 'class Base {\npublic:\n    virtual void print() { cout << "Base\\n"; }\n    virtual ~Base() = default;\n};\nclass Derived : public Base {\npublic:\n    void print() override { cout << "Derived\\n"; }\n};\nvoid process(Base* obj) {\n    obj->print();  // Runtime polymorphism\n}', 'Virtual functions enable runtime polymorphism. Override in derived classes. Virtual destructor prevents memory leaks. vtable manages dispatch.', 3, 9),
(3, 6, 'Decorator Pattern', 'class Coffee {\npublic:\n    virtual double cost() = 0;\n    virtual string description() = 0;\n};\nclass CoffeeDecorator : public Coffee {\nprotected:\n    Coffee* coffee;\npublic:\n    CoffeeDecorator(Coffee* c) : coffee(c) {}\n};\nclass Milk : public CoffeeDecorator {\npublic:\n    double cost() override { return coffee->cost() + 0.5; }\n    string description() override { return coffee->description() + ", milk"; }\n};', 'Decorator adds functionality without altering structure. Wraps objects recursively. Alternative to subclassing. Used in I/O streams.', 3, 9),
(3, 7, 'Thread Pool Implementation', '#include <thread>\n#include <queue>\n#include <condition_variable>\nclass ThreadPool {\n    vector<thread> workers;\n    queue<function<void()>> tasks;\n    mutex queue_mutex;\n    condition_variable cv;\n    bool stop = false;\npublic:\n    ThreadPool(size_t threads) {\n        for(size_t i = 0; i < threads; ++i)\n            workers.emplace_back([this] { work(); });\n    }\n    void enqueue(function<void()> task) {\n        unique_lock<mutex> lock(queue_mutex);\n        tasks.push(task);\n        cv.notify_one();\n    }\n};', 'Thread pools reuse threads for tasks. Avoids creation overhead. Queue manages work distribution. Essential for scalable concurrent systems.', 3, 6),
(3, 8, 'SQL Transaction ACID', 'BEGIN TRANSACTION;\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\nIF @@ERROR != 0\n    ROLLBACK TRANSACTION;\nELSE\n    COMMIT TRANSACTION;\n\n-- Isolation levels\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n-- READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ', 'ACID ensures database reliability. Atomicity: all or nothing. Consistency: valid states. Isolation: concurrent safety. Durability: permanent changes.', 10, 3),
(3, 9, 'Strategy Pattern', 'class SortStrategy {\npublic:\n    virtual void sort(vector<int>& data) = 0;\n};\nclass QuickSort : public SortStrategy {\n    void sort(vector<int>& data) override { /* quicksort */ }\n};\nclass MergeSort : public SortStrategy {\n    void sort(vector<int>& data) override { /* mergesort */ }\n};\nclass Sorter {\n    SortStrategy* strategy;\npublic:\n    void setStrategy(SortStrategy* s) { strategy = s; }\n    void sort(vector<int>& data) { strategy->sort(data); }\n};', 'Strategy encapsulates algorithms. Switch algorithms at runtime. Eliminates conditional logic. Open/closed principle compliance.', 3, 9),
(3, 10, 'JavaScript Prototypes', 'function Person(name) {\n    this.name = name;\n}\nPerson.prototype.greet = function() {\n    return `Hello, I''m ${this.name}`;\n};\n\nfunction Employee(name, role) {\n    Person.call(this, name);\n    this.role = role;\n}\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\nEmployee.prototype.work = function() {\n    return `${this.name} works as ${this.role}`;\n};', 'Prototypes enable inheritance in JavaScript. Objects inherit from prototype chain. Methods shared across instances. Memory efficient.', 5, 9),
(3, 11, 'Memento Pattern', 'class Memento {\n    string state;\npublic:\n    Memento(const string& s) : state(s) {}\n    string getState() const { return state; }\n};\nclass Originator {\n    string state;\npublic:\n    void setState(const string& s) { state = s; }\n    Memento saveToMemento() { return Memento(state); }\n    void restoreFromMemento(const Memento& m) { state = m.getState(); }\n};', 'Memento captures object state for restoration. Implements undo/redo. Preserves encapsulation. Used in text editors, games.', 3, 9),
(3, 12, 'Python Metaclasses', 'class SingletonMeta(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=SingletonMeta):\n    def __init__(self):\n        self.connection = "Connected"\n\ndb1 = Database()\ndb2 = Database()\nprint(db1 is db2)  # True', 'Metaclasses control class creation. type is default metaclass. Customize class behavior, attributes. Advanced Python magic.', 1, 9),
(3, 13, 'Command Pattern', 'class Command {\npublic:\n    virtual void execute() = 0;\n    virtual void undo() = 0;\n};\nclass LightOnCommand : public Command {\n    Light* light;\npublic:\n    LightOnCommand(Light* l) : light(l) {}\n    void execute() override { light->on(); }\n    void undo() override { light->off(); }\n};\nclass RemoteControl {\n    vector<Command*> commands;\npublic:\n    void setCommand(int slot, Command* cmd) { commands[slot] = cmd; }\n    void pressButton(int slot) { commands[slot]->execute(); }\n};', 'Command encapsulates requests as objects. Enables undo, queuing, logging. Decouples sender from receiver. Used in GUI buttons, macros.', 3, 9),
(3, 14, 'Proxy Pattern', 'class ImageProxy : public Image {\n    RealImage* realImage;\n    string filename;\npublic:\n    ImageProxy(const string& file) : filename(file), realImage(nullptr) {}\n    void display() override {\n        if (!realImage) {\n            realImage = new RealImage(filename);  // Lazy loading\n        }\n        realImage->display();\n    }\n    ~ImageProxy() { delete realImage; }\n};', 'Proxy provides placeholder for object. Controls access, lazy loading, caching. Virtual proxy delays expensive operations. Security proxy adds access control.', 3, 9),
(3, 15, 'Template Method Pattern', 'class DataProcessor {\npublic:\n    void process() {\n        readData();\n        processData();\n        writeData();\n    }\nprotected:\n    virtual void readData() = 0;\n    virtual void processData() = 0;\n    virtual void writeData() = 0;\n};\nclass CSVProcessor : public DataProcessor {\nprotected:\n    void readData() override { /* Read CSV */ }\n    void processData() override { /* Process */ }\n    void writeData() override { /* Write CSV */ }\n};', 'Template method defines algorithm skeleton. Subclasses override specific steps. Enforces algorithm structure. Hollywood principle: dont call us.', 3, 9),
(3, 16, 'Rust Traits', 'trait Drawable {\n    fn draw(&self);\n}\nstruct Circle { radius: f64 }\nstruct Square { side: f64 }\nimpl Drawable for Circle {\n    fn draw(&self) {\n        println!("Drawing circle with radius {}", self.radius);\n    }\n}\nimpl Drawable for Square {\n    fn draw(&self) {\n        println!("Drawing square with side {}", self.side);\n    }\n}\nfn render(shape: &dyn Drawable) {\n    shape.draw();\n}', 'Traits define shared behavior. Similar to interfaces. Static or dynamic dispatch. Zero-cost abstractions. Rust polymorphism foundation.', 7, 9),
(3, 17, 'Builder Pattern', 'class CarBuilder {\n    Car car;\npublic:\n    CarBuilder& setEngine(const string& engine) {\n        car.engine = engine; return *this;\n    }\n    CarBuilder& setWheels(int wheels) {\n        car.wheels = wheels; return *this;\n    }\n    CarBuilder& setColor(const string& color) {\n        car.color = color; return *this;\n    }\n    Car build() { return car; }\n};\n// Usage: Car car = CarBuilder().setEngine("V8").setWheels(4).build();', 'Builder constructs complex objects step-by-step. Fluent interface for readability. Separates construction from representation. Immutable objects.', 3, 9),
(3, 18, 'Adapter Pattern', 'class LegacyPrinter {\npublic:\n    void printOldFormat(const string& text) { /* ... */ }\n};\nclass ModernPrinter {\npublic:\n    virtual void print(const string& text) = 0;\n};\nclass PrinterAdapter : public ModernPrinter {\n    LegacyPrinter* legacy;\npublic:\n    PrinterAdapter(LegacyPrinter* l) : legacy(l) {}\n    void print(const string& text) override {\n        legacy->printOldFormat(text);\n    }\n};', 'Adapter makes incompatible interfaces work together. Wraps existing class with new interface. Enables legacy code integration.', 3, 9),
(3, 19, 'Python Abstract Base Classes', 'from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self): pass\n    \n    @abstractmethod\n    def perimeter(self): pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)', 'ABC enforces interface contracts. @abstractmethod must be implemented. Cannot instantiate abstract classes. Ensures consistent APIs.', 1, 9),
(3, 20, 'Composite Pattern', 'class Component {\npublic:\n    virtual void operation() = 0;\n    virtual void add(Component*) {}\n    virtual void remove(Component*) {}\n};\nclass Leaf : public Component {\n    void operation() override { /* leaf operation */ }\n};\nclass Composite : public Component {\n    vector<Component*> children;\npublic:\n    void add(Component* c) override { children.push_back(c); }\n    void operation() override {\n        for (auto child : children) child->operation();\n    }\n};', 'Composite treats objects uniformly. Tree structures with leaf and composite nodes. Part-whole hierarchies. Used in GUI, file systems.', 3, 9),
(3, 21, 'Chain of Responsibility', 'class Handler {\n    Handler* next;\npublic:\n    void setNext(Handler* h) { next = h; }\n    virtual void handle(Request& req) {\n        if (canHandle(req)) process(req);\n        else if (next) next->handle(req);\n    }\n    virtual bool canHandle(Request&) = 0;\n    virtual void process(Request&) = 0;\n};', 'Chain passes requests along handlers. Each decides to process or forward. Decouples sender from receivers. Used in event handling, logging.', 3, 9),
(3, 22, 'Go Interfaces', 'type Writer interface {\n    Write([]byte) (int, error)\n}\ntype ConsoleWriter struct{}\nfunc (cw ConsoleWriter) Write(data []byte) (int, error) {\n    n, err := fmt.Println(string(data))\n    return n, err\n}\ntype FileWriter struct { file *os.File }\nfunc (fw FileWriter) Write(data []byte) (int, error) {\n    return fw.file.Write(data)\n}\nfunc save(w Writer, data []byte) {\n    w.Write(data)\n}', 'Go interfaces are implicit. Types satisfy interface by implementing methods. Duck typing with compile-time safety. Composition over inheritance.', 6, 9),
(3, 23, 'Flyweight Pattern', 'class Character {\n    char symbol;\n    Font* font;  // Shared\npublic:\n    Character(char s, Font* f) : symbol(s), font(f) {}\n    void display(int x, int y) {\n        font->render(symbol, x, y);\n    }\n};\nclass FontFactory {\n    unordered_map<string, Font*> fonts;\npublic:\n    Font* getFont(const string& name) {\n        if (!fonts[name]) fonts[name] = new Font(name);\n        return fonts[name];\n    }\n};', 'Flyweight shares common data between objects. Intrinsic vs extrinsic state. Reduces memory usage. Used in text editors, games.', 3, 9),
(3, 24, 'Bridge Pattern', 'class Renderer {\npublic:\n    virtual void renderCircle(float x, float y, float r) = 0;\n};\nclass VectorRenderer : public Renderer { /* ... */ };\nclass RasterRenderer : public Renderer { /* ... */ };\n\nclass Shape {\nprotected:\n    Renderer* renderer;\npublic:\n    Shape(Renderer* r) : renderer(r) {}\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\n    float x, y, radius;\npublic:\n    void draw() override { renderer->renderCircle(x, y, radius); }\n};', 'Bridge separates abstraction from implementation. Both can vary independently. Avoids class explosion. Prefer composition over inheritance.', 3, 9),
(3, 25, 'Visitor Pattern', 'class Visitor {\npublic:\n    virtual void visit(Circle*) = 0;\n    virtual void visit(Square*) = 0;\n};\nclass Shape {\npublic:\n    virtual void accept(Visitor*) = 0;\n};\nclass Circle : public Shape {\n    void accept(Visitor* v) override { v->visit(this); }\n};\nclass AreaCalculator : public Visitor {\n    void visit(Circle* c) override { /* calc circle area */ }\n    void visit(Square* s) override { /* calc square area */ }\n};', 'Visitor adds operations without modifying classes. Double dispatch for type resolution. Open/closed principle. Used in compilers, AST processing.', 3, 9),
(3, 26, 'TypeScript Mixins', 'type Constructor<T = {}> = new (...args: any[]) => T;\nfunction Timestamped<T extends Constructor>(Base: T) {\n    return class extends Base {\n        timestamp = Date.now();\n    };\n}\nfunction Activatable<T extends Constructor>(Base: T) {\n    return class extends Base {\n        isActive = false;\n        activate() { this.isActive = true; }\n        deactivate() { this.isActive = false; }\n    };\n}\nclass User { name = "user"; }\nconst TimestampedUser = Timestamped(Activatable(User));', 'Mixins add functionality to classes. Composition of behaviors. Alternative to multiple inheritance. Flexible code reuse pattern.', 12, 9),
(3, 27, 'State Pattern', 'class State {\npublic:\n    virtual void handle(Context*) = 0;\n};\nclass ConcreteStateA : public State {\n    void handle(Context* ctx) override {\n        // Do work, then transition\n        ctx->setState(new ConcreteStateB());\n    }\n};\nclass Context {\n    State* state;\npublic:\n    void setState(State* s) { delete state; state = s; }\n    void request() { state->handle(this); }\n};', 'State pattern changes object behavior based on state. Eliminates conditionals. State machines. Used in TCP connections, UI workflows.', 3, 9),
(3, 28, 'Interpreter Pattern', 'class Expression {\npublic:\n    virtual int interpret(Context&) = 0;\n};\nclass Number : public Expression {\n    int value;\npublic:\n    Number(int v) : value(v) {}\n    int interpret(Context&) override { return value; }\n};\nclass Plus : public Expression {\n    Expression *left, *right;\npublic:\n    Plus(Expression* l, Expression* r) : left(l), right(r) {}\n    int interpret(Context& ctx) override {\n        return left->interpret(ctx) + right->interpret(ctx);\n    }\n};', 'Interpreter evaluates language grammar. Abstract syntax tree. Each rule is a class. Used in SQL parsing, regex, calculators.', 3, 9),
(3, 29, 'Null Object Pattern', 'class Logger {\npublic:\n    virtual void log(const string&) = 0;\n};\nclass ConsoleLogger : public Logger {\n    void log(const string& msg) override { cout << msg << endl; }\n};\nclass NullLogger : public Logger {\n    void log(const string&) override { /* Do nothing */ }\n};\nclass App {\n    Logger* logger;\npublic:\n    App(Logger* l = new NullLogger()) : logger(l) {}\n    void doWork() { logger->log("Working..."); }\n};', 'Null object provides default do-nothing behavior. Eliminates null checks. Polymorphic approach to optional behavior. Cleaner code flow.', 3, 9),
(3, 30, 'Python Multiple Inheritance', 'class Flyable:\n    def fly(self):\n        return "Flying"\n\nclass Swimmable:\n    def swim(self):\n        return "Swimming"\n\nclass Duck(Flyable, Swimmable):\n    def quack(self):\n        return "Quack!"\n\n# Method Resolution Order (MRO)\nprint(Duck.__mro__)\n# Diamond problem solution\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B, C): pass  # Python C3 linearization', 'Multiple inheritance allows multiple parent classes. MRO determines method lookup order. C3 linearization resolves diamonds. Use carefully.', 1, 9),
(3, 31, 'SOLID Principles Summary', '// Single Responsibility\nclass User { /* user data */ };\nclass UserDB { /* database ops */ };\n\n// Open/Closed\nclass Shape { virtual double area() = 0; };\n\n// Liskov Substitution\n// Derived classes must be substitutable\n\n// Interface Segregation\nclass Printer { virtual void print() = 0; };\nclass Scanner { virtual void scan() = 0; };\n\n// Dependency Inversion\nclass App {\n    IDatabase* db;  // Depend on abstraction\npublic:\n    App(IDatabase* database) : db(database) {}\n};', 'SOLID guides OOP design. SRP: one reason to change. OCP: extend, dont modify. LSP: behavioral subtyping. ISP: specific interfaces. DIP: abstractions.', 3, 9);